rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {
    // Helper functions for validation
    function isValidUserData(data) {
      return data.keys().hasAll(['displayName', 'email']) &&
             data.displayName is string &&
             data.displayName.size() > 0 &&
             data.displayName.size() <= 50 &&
             data.email is string &&
             data.email.matches('^[^@]+@[^@]+\\.[^@]+$');
    }
    
    function isValidQuizData(data) {
      return data.keys().hasAll(['title', 'categoryId', 'difficulty']) &&
             data.title is string &&
             data.title.size() >= 3 &&
             data.title.size() <= 100 &&
             data.categoryId is string &&
             data.categoryId.size() > 0 &&
             data.difficulty in ['easy', 'medium', 'hard'];
    }
    
    function isValidQuestionData(data) {
      return data.keys().hasAll(['questionText', 'answerOptions', 'correctAnswer']) &&
             data.questionText is string &&
             data.questionText.size() >= 10 &&
             data.questionText.size() <= 500 &&
             data.answerOptions is list &&
             data.answerOptions.size() >= 2 &&
             data.answerOptions.size() <= 6 &&
             data.correctAnswer is number &&
             data.correctAnswer >= 0 &&
             data.correctAnswer < data.answerOptions.size();
    }
    
    function isAuthenticated() {
      return request.auth != null;
    }
    
    function isOwner(userId) {
      return isAuthenticated() && request.auth.uid == userId;
    }
    
    function isAdmin() {
      return isAuthenticated() && request.auth.token.admin == true;
    }
    
    function isModerator() {
      return isAuthenticated() && request.auth.token.moderator == true;
    }
    
    function hasRole(role) {
      return isAuthenticated() && request.auth.token[role] == true;
    }
    
    function isValidTimestamp(timestamp) {
      return timestamp is timestamp &&
             timestamp <= request.time &&
             timestamp > timestamp.date(2020, 1, 1);
    }
    
    function isValidEmail(email) {
      return email is string &&
             email.matches('^[^@]+@[^@]+\\.[^@]+$') &&
             email.size() <= 100;
    }
    
    function isValidDisplayName(name) {
      return name is string &&
             name.size() >= 2 &&
             name.size() <= 50 &&
             name.matches('^[a-zA-Z0-9\\s\\-_]+$');
    }
    
    function isValidScore(score) {
      return score is number &&
             score >= 0 &&
             score <= 100;
    }
    
    function isValidXP(xp) {
      return xp is number &&
             xp >= 0 &&
             xp <= 1000000;
    }
    
    function isValidLevel(level) {
      return level is number &&
             level >= 1 &&
             level <= 100;
    }
    
    function isValidCoins(coins) {
      return coins is number &&
             coins >= 0 &&
             coins <= 1000000;
    }
    
    // Rate limiting helper
    function isRateLimited() {
      return request.time.toMillis() - resource.data.lastRequest.toMillis() < 1000;
    }

    // User data - users can only read/write their own data with validation
    match /users/{userId} {
      allow read, write: if isOwner(userId) && 
        (request.method == 'get' || 
         (request.method == 'create' && isValidUserData(request.resource.data)) ||
         (request.method == 'update' && isValidUserData(request.resource.data)));
    }
    
    // User profiles - users can only read/write their own profile with validation
    match /user_profiles/{userId} {
      allow read, write: if isOwner(userId) && 
        (request.method == 'get' || 
         (request.method == 'create' && isValidUserData(request.resource.data)) ||
         (request.method == 'update' && isValidUserData(request.resource.data)));
    }
    
    // User stats - users can only read/write their own stats with validation
    match /user_stats/{userId} {
      allow read, write: if isOwner(userId) && 
        (request.method == 'get' || 
         (request.method == 'create' && 
          isValidXP(request.resource.data.xp) &&
          isValidLevel(request.resource.data.level) &&
          isValidCoins(request.resource.data.coins)) ||
         (request.method == 'update' && 
          isValidXP(request.resource.data.xp) &&
          isValidLevel(request.resource.data.level) &&
          isValidCoins(request.resource.data.coins)));
    }
    
    // User daily quiz completions - users can only read/write their own completions
    match /user_daily_quizzes/{completionId} {
      allow create: if isAuthenticated() && 
        request.resource.data.userId == request.auth.uid &&
        isValidScore(request.resource.data.score) &&
        isValidTimestamp(request.resource.data.completedAt);
      allow read, update: if isAuthenticated() && 
        resource.data.userId == request.auth.uid;
    }
    
    // Quizzes - authenticated users can read, creators can write with validation
    match /quizzes/{quizId} {
      allow read: if isAuthenticated();
      allow write: if isAuthenticated() && 
        (resource == null || resource.data.createdBy == request.auth.uid) &&
        (request.method == 'create' && isValidQuizData(request.resource.data)) ||
        (request.method == 'update' && isValidQuizData(request.resource.data));
    }
    
    // Questions - authenticated users can read, creators can write with validation
    match /questions/{questionId} {
      allow read: if isAuthenticated();
      allow write: if isAuthenticated() && 
        (resource == null || resource.data.createdBy == request.auth.uid) &&
        (request.method == 'create' && isValidQuestionData(request.resource.data)) ||
        (request.method == 'update' && isValidQuestionData(request.resource.data));
    }
    
    // Categories - authenticated users can read, admins can write
    match /categories/{categoryId} {
      allow read: if isAuthenticated();
      allow write: if isAdmin() &&
        request.resource.data.keys().hasAll(['name', 'description']) &&
        request.resource.data.name is string &&
        request.resource.data.name.size() > 0 &&
        request.resource.data.name.size() <= 50;
    }
    
    // Quiz attempts - users can only read/write their own attempts with validation
    match /quiz_attempts/{attemptId} {
      allow create: if isAuthenticated() && 
        request.resource.data.userId == request.auth.uid &&
        isValidScore(request.resource.data.score) &&
        isValidTimestamp(request.resource.data.startedAt) &&
        isValidTimestamp(request.resource.data.completedAt);
      allow read, update: if isAuthenticated() && 
        resource.data.userId == request.auth.uid;
    }
    
    // Daily quizzes - authenticated users can read, admins can write
    match /daily_quizzes/{date} {
      allow read: if isAuthenticated();
      allow write: if isAdmin() &&
        request.resource.data.keys().hasAll(['quizId', 'date']) &&
        request.resource.data.date is string &&
        request.resource.data.date.matches('^\\d{4}-\\d{2}-\\d{2}$');
    }
    
    // Leaderboards - authenticated users can read, users can write their own entries with validation
    match /leaderboards/{entryId} {
      allow read: if isAuthenticated();
      allow create: if isAuthenticated() && 
        request.resource.data.userId == request.auth.uid &&
        isValidScore(request.resource.data.score) &&
        isValidTimestamp(request.resource.data.timestamp);
      allow update, delete: if isAuthenticated() && 
        resource.data.userId == request.auth.uid;
    }
    
    // Leaderboard entries - authenticated users can read, users can write their own entries
    match /leaderboard_entries/{entryId} {
      allow read: if isAuthenticated();
      allow create: if isAuthenticated() && 
        request.resource.data.userId == request.auth.uid &&
        isValidScore(request.resource.data.score) &&
        isValidTimestamp(request.resource.data.timestamp);
      allow update, delete: if isAuthenticated() && 
        resource.data.userId == request.auth.uid;
    }
    
    // Achievements - authenticated users can read, admins can write
    match /achievements/{achievementId} {
      allow read: if isAuthenticated();
      allow write: if isAdmin() &&
        request.resource.data.keys().hasAll(['name', 'description', 'criteria']) &&
        request.resource.data.name is string &&
        request.resource.data.name.size() > 0 &&
        request.resource.data.name.size() <= 100;
    }
    
    // User achievements - users can only read/write their own achievements
    match /user_achievements/{achievementId} {
      allow read, write: if isAuthenticated() && 
        resource.data.userId == request.auth.uid;
    }
    
    // Content - authenticated users can read, admins can write
    match /content/{contentId} {
      allow read: if isAuthenticated();
      allow write: if isAdmin() &&
        request.resource.data.keys().hasAll(['title', 'content', 'type']) &&
        request.resource.data.title is string &&
        request.resource.data.title.size() > 0 &&
        request.resource.data.title.size() <= 200;
    }
    
    // Announcements - authenticated users can read, admins can write
    match /announcements/{announcementId} {
      allow read: if isAuthenticated();
      allow write: if isAdmin() &&
        request.resource.data.keys().hasAll(['title', 'message', 'priority']) &&
        request.resource.data.title is string &&
        request.resource.data.title.size() > 0 &&
        request.resource.data.title.size() <= 200 &&
        request.resource.data.priority in ['low', 'medium', 'high'];
    }
    
    // Analytics - only admins can read/write
    match /analytics/{analyticsId} {
      allow read, write: if isAdmin();
    }
    
    // User activity - users can only read/write their own activity
    match /user_activity/{activityId} {
      allow read, write: if isAuthenticated() && 
        resource.data.userId == request.auth.uid &&
        isValidTimestamp(request.resource.data.timestamp);
    }
    
    // System config - only admins can read/write
    match /system_config/{configId} {
      allow read, write: if isAdmin();
    }
    
    // Maintenance - only admins can read/write
    match /maintenance/{maintenanceId} {
      allow read, write: if isAdmin();
    }
    
    // Rate limiting collection - internal use only
    match /rate_limits/{limitId} {
      allow read, write: if false; // Only accessible by server-side functions
    }
    
    // Audit logs - only admins can read
    match /audit_logs/{logId} {
      allow read: if isAdmin();
      allow write: if false; // Only writable by server-side functions
    }
    
    // User sessions - users can only read/write their own sessions
    match /user_sessions/{sessionId} {
      allow read, write: if isAuthenticated() && 
        resource.data.userId == request.auth.uid &&
        isValidTimestamp(request.resource.data.createdAt) &&
        isValidTimestamp(request.resource.data.expiresAt);
    }
    
    // User preferences - users can only read/write their own preferences
    match /user_preferences/{userId} {
      allow read, write: if isOwner(userId) &&
        request.resource.data.keys().hasAll(['theme', 'language', 'notifications']) &&
        request.resource.data.theme in ['light', 'dark', 'system'] &&
        request.resource.data.language is string &&
        request.resource.data.language.size() >= 2 &&
        request.resource.data.language.size() <= 10;
    }
    
    // User privacy settings - users can only read/write their own settings
    match /user_privacy/{userId} {
      allow read, write: if isOwner(userId) &&
        request.resource.data.keys().hasAll(['profileVisibility', 'showOnlineStatus']) &&
        request.resource.data.profileVisibility in ['public', 'friends', 'private'];
    }
    
    // Quiz categories - authenticated users can read, admins can write
    match /quiz_categories/{categoryId} {
      allow read: if isAuthenticated();
      allow write: if isAdmin() &&
        request.resource.data.keys().hasAll(['name', 'description', 'icon']) &&
        request.resource.data.name is string &&
        request.resource.data.name.size() > 0 &&
        request.resource.data.name.size() <= 50;
    }
    
    // Quiz questions - authenticated users can read, creators can write
    match /quiz_questions/{questionId} {
      allow read: if isAuthenticated();
      allow write: if isAuthenticated() && 
        (resource == null || resource.data.createdBy == request.auth.uid) &&
        isValidQuestionData(request.resource.data);
    }
    
    // Quiz submissions - users can only read/write their own submissions
    match /quiz_submissions/{submissionId} {
      allow create: if isAuthenticated() && 
        request.resource.data.userId == request.auth.uid &&
        isValidScore(request.resource.data.score) &&
        isValidTimestamp(request.resource.data.submittedAt);
      allow read, update: if isAuthenticated() && 
        resource.data.userId == request.auth.uid;
    }
    
    // User feedback - authenticated users can create, admins can read
    match /user_feedback/{feedbackId} {
      allow create: if isAuthenticated() &&
        request.resource.data.userId == request.auth.uid &&
        request.resource.data.message is string &&
        request.resource.data.message.size() > 0 &&
        request.resource.data.message.size() <= 1000 &&
        request.resource.data.type in ['bug', 'feature', 'general'];
      allow read: if isAdmin();
    }
    
    // System notifications - users can read their own, admins can write
    match /notifications/{notificationId} {
      allow read: if isAuthenticated() && 
        resource.data.userId == request.auth.uid;
      allow write: if isAdmin() &&
        request.resource.data.keys().hasAll(['userId', 'title', 'message', 'type']) &&
        isValidDisplayName(request.resource.data.title) &&
        request.resource.data.message is string &&
        request.resource.data.message.size() > 0 &&
        request.resource.data.message.size() <= 500 &&
        request.resource.data.type in ['info', 'warning', 'error', 'success'];
    }
    
    // ===========================================
    // SOCIAL/FRIENDS FEATURES
    // ===========================================
    
    // Helper functions for social features
    function isValidFriendRequestStatus(status) {
      return status in ['pending', 'accepted', 'declined', 'blocked'];
    }
    
    function isValidChallengeStatus(status) {
      return status in ['pending', 'accepted', 'declined', 'in_progress', 'completed', 'expired'];
    }
    
    function isValidActivityType(type) {
      return type in ['quiz_completed', 'achievement_unlocked', 'challenge_sent', 'challenge_completed', 'level_up'];
    }
    
    function isFriendRequestParticipant(data) {
      return request.auth.uid == data.fromUserId || request.auth.uid == data.toUserId;
    }
    
    function isFriendshipParticipant(data) {
      return request.auth.uid == data.userId1 || request.auth.uid == data.userId2;
    }
    
    function isChallengeParticipant(data) {
      return request.auth.uid == data.fromUserId || request.auth.uid == data.toUserId;
    }
    
    // Friend requests - users can send/receive/manage their own requests
    match /friend_requests/{requestId} {
      // Anyone can read requests they're part of
      allow read: if isAuthenticated() && 
        isFriendRequestParticipant(resource.data);
      
      // Users can create requests where they are the sender
      allow create: if isAuthenticated() && 
        request.resource.data.fromUserId == request.auth.uid &&
        request.resource.data.toUserId != request.auth.uid && // Can't friend yourself
        request.resource.data.keys().hasAll(['fromUserId', 'toUserId', 'status', 'createdAt']) &&
        request.resource.data.status == 'pending' &&
        request.resource.data.fromUserDisplayName is string &&
        request.resource.data.fromUserDisplayName.size() > 0 &&
        request.resource.data.fromUserDisplayName.size() <= 50;
      
      // Sender can update (cancel) or receiver can update (accept/decline)
      allow update: if isAuthenticated() && 
        isFriendRequestParticipant(resource.data) &&
        isValidFriendRequestStatus(request.resource.data.status) &&
        // Sender can only cancel (set to declined)
        (request.auth.uid == resource.data.fromUserId && request.resource.data.status == 'declined') ||
        // Receiver can accept or decline
        (request.auth.uid == resource.data.toUserId && request.resource.data.status in ['accepted', 'declined', 'blocked']);
      
      // Participants can delete their requests
      allow delete: if isAuthenticated() && 
        isFriendRequestParticipant(resource.data);
    }
    
    // Friendships - bidirectional friend relationships
    match /friendships/{friendshipId} {
      // Participants can read their friendships
      allow read: if isAuthenticated() && 
        isFriendshipParticipant(resource.data);
      
      // Create friendship (typically done when request is accepted)
      allow create: if isAuthenticated() && 
        isFriendshipParticipant(request.resource.data) &&
        request.resource.data.keys().hasAll(['userId1', 'userId2', 'createdAt']) &&
        request.resource.data.userId1 != request.resource.data.userId2 && // Different users
        request.resource.data.isBlocked == false; // Can't create blocked friendships directly
      
      // Participants can update friendship settings
      allow update: if isAuthenticated() && 
        isFriendshipParticipant(resource.data) &&
        // Cannot change the user IDs
        request.resource.data.userId1 == resource.data.userId1 &&
        request.resource.data.userId2 == resource.data.userId2 &&
        // If blocking, must be the blocker
        (request.resource.data.isBlocked == false || 
         request.resource.data.blockedBy == request.auth.uid);
      
      // Participants can delete (unfriend)
      allow delete: if isAuthenticated() && 
        isFriendshipParticipant(resource.data);
    }
    
    // Challenges - friend-to-friend quiz competitions
    match /challenges/{challengeId} {
      // Participants can read their challenges
      allow read: if isAuthenticated() && 
        isChallengeParticipant(resource.data);
      
      // Users can create challenges where they are the sender
      allow create: if isAuthenticated() && 
        request.resource.data.fromUserId == request.auth.uid &&
        request.resource.data.toUserId != request.auth.uid && // Can't challenge yourself
        request.resource.data.keys().hasAll(['fromUserId', 'toUserId', 'quizId', 'status', 'createdAt', 'expiresAt']) &&
        request.resource.data.status == 'pending' &&
        isValidDisplayName(request.resource.data.fromUserDisplayName) &&
        isValidDisplayName(request.resource.data.toUserDisplayName) &&
        request.resource.data.quizTitle is string &&
        request.resource.data.quizTitle.size() > 0 &&
        request.resource.data.quizTitle.size() <= 200;
      
      // Participants can update challenges based on their role
      allow update: if isAuthenticated() && 
        isChallengeParticipant(resource.data) &&
        isValidChallengeStatus(request.resource.data.status) &&
        // Cannot change participants or quiz
        request.resource.data.fromUserId == resource.data.fromUserId &&
        request.resource.data.toUserId == resource.data.toUserId &&
        request.resource.data.quizId == resource.data.quizId &&
        (
          // Receiver can accept or decline pending challenges
          (request.auth.uid == resource.data.toUserId && 
           resource.data.status == 'pending' && 
           request.resource.data.status in ['accepted', 'declined']) ||
          // Participants can submit their scores during in_progress
          (resource.data.status in ['accepted', 'in_progress'] && 
           request.resource.data.status in ['in_progress', 'completed'] &&
           // Validate score updates
           (request.resource.data.fromUserScore == null || isValidScore(request.resource.data.fromUserScore)) &&
           (request.resource.data.toUserScore == null || isValidScore(request.resource.data.toUserScore)))
        );
      
      // Sender can delete pending challenges
      allow delete: if isAuthenticated() && 
        request.auth.uid == resource.data.fromUserId && 
        resource.data.status == 'pending';
    }
    
    // Friend activities - activity feed items
    match /friend_activities/{activityId} {
      // Authenticated users can read activities (visibility controlled by query/app logic)
      allow read: if isAuthenticated();
      
      // Users can create their own activities
      allow create: if isAuthenticated() && 
        request.resource.data.userId == request.auth.uid &&
        request.resource.data.keys().hasAll(['userId', 'type', 'title', 'createdAt']) &&
        isValidActivityType(request.resource.data.type) &&
        request.resource.data.title is string &&
        request.resource.data.title.size() > 0 &&
        request.resource.data.title.size() <= 200 &&
        (request.resource.data.description == null || 
         (request.resource.data.description is string && 
          request.resource.data.description.size() <= 500));
      
      // Users can update their own activities (e.g., likes count)
      allow update: if isAuthenticated() && 
        resource.data.userId == request.auth.uid &&
        // Cannot change core fields
        request.resource.data.userId == resource.data.userId &&
        request.resource.data.type == resource.data.type;
      
      // Users can delete their own activities
      allow delete: if isAuthenticated() && 
        resource.data.userId == request.auth.uid;
    }
    
    // Activity likes - track who liked which activity
    match /activity_likes/{likeId} {
      allow read: if isAuthenticated();
      
      allow create: if isAuthenticated() && 
        request.resource.data.userId == request.auth.uid &&
        request.resource.data.keys().hasAll(['userId', 'activityId', 'createdAt']);
      
      allow delete: if isAuthenticated() && 
        resource.data.userId == request.auth.uid;
    }
    
    // Friend notifications - users can manage their friend-related notifications
    match /friend_notifications/{notificationId} {
      allow read: if isAuthenticated() && 
        resource.data.userId == request.auth.uid;
      
      // System/triggers create notifications
      allow create: if isAuthenticated() && 
        request.resource.data.userId != null &&
        request.resource.data.keys().hasAll(['userId', 'type', 'title', 'createdAt']) &&
        request.resource.data.type in ['friend_request', 'friend_accepted', 'challenge_received', 'challenge_accepted', 'challenge_completed', 'message_received'];
      
      // Users can update (mark as read) their own notifications
      allow update: if isAuthenticated() && 
        resource.data.userId == request.auth.uid;
      
      // Users can delete their own notifications
      allow delete: if isAuthenticated() && 
        resource.data.userId == request.auth.uid;
    }

    // ===========================================
    // MESSAGING
    // ===========================================

    // Helper function for conversation participants
    function isConversationParticipant(participantIds) {
      return request.auth.uid in participantIds;
    }

    // Conversations - direct message threads between two users
    match /conversations/{conversationId} {
      // Participants can read their conversations
      allow read: if isAuthenticated() && 
        isConversationParticipant(resource.data.participantIds);
      
      // Users can create conversations they're part of
      allow create: if isAuthenticated() && 
        request.auth.uid in request.resource.data.participantIds &&
        request.resource.data.participantIds.size() == 2 &&
        request.resource.data.keys().hasAll(['participantIds', 'createdAt', 'updatedAt']);
      
      // Participants can update (mark as read, new message preview)
      allow update: if isAuthenticated() && 
        isConversationParticipant(resource.data.participantIds) &&
        // Cannot change participants
        request.resource.data.participantIds == resource.data.participantIds;
      
      // No deletion - conversations persist
      allow delete: if false;
    }

    // Messages - individual messages within conversations
    match /messages/{messageId} {
      // Users can read messages in their conversations
      // Note: Security relies on conversation access check in app logic
      allow read: if isAuthenticated();
      
      // Users can create messages they send
      allow create: if isAuthenticated() && 
        request.resource.data.senderId == request.auth.uid &&
        request.resource.data.keys().hasAll(['conversationId', 'senderId', 'recipientId', 'content', 'createdAt']) &&
        request.resource.data.content is string &&
        request.resource.data.content.size() > 0 &&
        request.resource.data.content.size() <= 2000;
      
      // Recipients can update (mark as read)
      allow update: if isAuthenticated() && 
        resource.data.recipientId == request.auth.uid &&
        // Can only update read status
        request.resource.data.senderId == resource.data.senderId &&
        request.resource.data.recipientId == resource.data.recipientId &&
        request.resource.data.content == resource.data.content &&
        request.resource.data.conversationId == resource.data.conversationId;
      
      // No deletion of messages
      allow delete: if false;
    }
  }
}